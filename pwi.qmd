---
title: "Picture-Word Interference Experiment"
format:
  html:
    page-layout: full
    toc: false
embed-resources: true
---

```{=html}
<style>
  #experiment-container {
    max-width: 800px;
    margin: 0 auto;
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  #version-select {
    padding: 40px 20px;
  }

  .version-card {
    background: #fff;
    border: 2px solid #ddd;
    border-radius: 12px;
    padding: 25px;
    margin: 15px 0;
    cursor: pointer;
    transition: all 0.2s;
    text-align: left;
  }

  .version-card:hover {
    border-color: #3498db;
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
    transform: translateY(-2px);
  }

  .version-card h3 {
    margin: 0 0 10px 0;
    color: #2c3e50;
  }

  .version-card .soa {
    display: inline-block;
    background: #ecf0f1;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 10px;
  }

  .version-card.phonological .soa { background: #e8f6ff; color: #2980b9; }
  .version-card.semantic .soa { background: #fef3e8; color: #e67e22; }
  .version-card.conceptual .soa { background: #f5e8fe; color: #9b59b6; }

  .version-card p {
    margin: 0;
    color: #7f8c8d;
    font-size: 14px;
  }

  .version-card .example {
    margin-top: 12px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 6px;
    font-size: 13px;
  }

  .version-card .example strong {
    color: #2c3e50;
  }

  #stimulus-display {
    width: 500px;
    height: 400px;
    margin: 20px auto;
    position: relative;
    border: 2px solid #333;
    border-radius: 8px;
    background: #f5f5f5;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #fixation {
    font-size: 72px;
    font-weight: bold;
    color: #333;
  }

  #picture-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #picture {
    max-width: 300px;
    max-height: 300px;
    font-size: 120px;
    opacity: 0;
    transition: opacity 0.05s;
  }

  #picture.visible {
    opacity: 1;
  }

  #distractor-word {
    position: absolute;
    font-size: 32px;
    font-weight: bold;
    color: #e74c3c;
    text-transform: uppercase;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.05s;
  }

  #distractor-word.visible {
    opacity: 1;
  }

  #feedback {
    font-size: 24px;
    margin: 20px 0;
    min-height: 40px;
  }

  .correct { color: #27ae60; }
  .incorrect { color: #e74c3c; }

  #instructions {
    background: #ecf0f1;
    padding: 20px;
    border-radius: 8px;
    margin: 20px 0;
    text-align: left;
  }

  #instructions h3 {
    margin-top: 0;
  }

  .btn {
    background: #3498db;
    color: white;
    border: none;
    padding: 12px 24px;
    font-size: 18px;
    border-radius: 6px;
    cursor: pointer;
    margin: 5px;
    transition: background 0.2s;
  }

  .btn:hover {
    background: #2980b9;
  }

  .btn:disabled {
    background: #bdc3c7;
    cursor: not-allowed;
  }

  .btn-secondary {
    background: #95a5a6;
  }

  .btn-secondary:hover {
    background: #7f8c8d;
  }

  #progress {
    font-size: 14px;
    color: #7f8c8d;
    margin: 10px 0;
  }

  #current-version {
    display: inline-block;
    padding: 5px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 10px;
  }

  #current-version.phonological { background: #e8f6ff; color: #2980b9; }
  #current-version.semantic { background: #fef3e8; color: #e67e22; }
  #current-version.conceptual { background: #f5e8fe; color: #9b59b6; }

  #results-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 14px;
  }

  #results-table th, #results-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }

  #results-table th {
    background: #3498db;
    color: white;
  }

  #results-table tr:nth-child(even) {
    background: #f9f9f9;
  }

  #summary-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin: 20px 0;
  }

  .stat-box {
    background: #ecf0f1;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
  }

  .stat-box .value {
    font-size: 28px;
    font-weight: bold;
    color: #2c3e50;
  }

  .stat-box .label {
    font-size: 12px;
    color: #7f8c8d;
    text-transform: uppercase;
  }

  #condition-comparison {
    margin: 30px 0;
  }

  .condition-bar {
    display: flex;
    align-items: center;
    margin: 10px 0;
  }

  .condition-label {
    width: 140px;
    text-align: right;
    padding-right: 15px;
    font-weight: bold;
    font-size: 14px;
  }

  .bar-container {
    flex: 1;
    height: 30px;
    background: #ecf0f1;
    border-radius: 4px;
    overflow: hidden;
  }

  .bar {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 10px;
    color: white;
    font-weight: bold;
    transition: width 0.5s ease;
  }

  .bar.related { background: #e74c3c; }
  .bar.unrelated { background: #3498db; }
  .bar.neutral { background: #95a5a6; }

  .timing-diagram {
    background: #2c3e50;
    padding: 20px;
    border-radius: 8px;
    margin: 15px 0;
    color: white;
  }

  .timing-diagram .timeline {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    font-family: monospace;
  }

  .timing-diagram .marker {
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
  }

  .timing-diagram .marker.distractor { background: #e74c3c; }
  .timing-diagram .marker.picture { background: #27ae60; }
  .timing-diagram .marker.gap { background: transparent; border: 1px dashed #7f8c8d; }

  #response-text:disabled {
    background: #ecf0f1;
    border-color: #bdc3c7;
    cursor: not-allowed;
  }

  #response-text:enabled {
    background: #fff;
    border-color: #27ae60;
    box-shadow: 0 0 5px rgba(39, 174, 96, 0.3);
  }

  #typing-hint {
    transition: opacity 0.2s;
  }

  /* Fullscreen styles */
  .fullscreen-mode {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    max-width: 100vw !important;
    background: #fff !important;
    z-index: 9999 !important;
    overflow: auto !important;
    padding: 20px !important;
    box-sizing: border-box !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
  }

  .fullscreen-mode #stimulus-display {
    width: 80vw !important;
    max-width: 700px !important;
    height: 60vh !important;
    max-height: 500px !important;
  }

  .fullscreen-mode #picture {
    font-size: min(25vw, 180px) !important;
  }

  .fullscreen-mode #distractor-word {
    font-size: min(6vw, 48px) !important;
  }

  .fullscreen-mode #fixation {
    font-size: min(15vw, 100px) !important;
  }

  .fullscreen-mode #response-text {
    font-size: 24px !important;
    padding: 15px !important;
    width: 350px !important;
  }

  .fullscreen-mode #feedback {
    font-size: 28px !important;
  }

  .fullscreen-mode #progress {
    font-size: 18px !important;
  }

  .fullscreen-mode #typing-hint {
    font-size: 14px !important;
  }
</style>

<div id="experiment-container">
  <h2>Picture-Word Interference Task</h2>

  <!-- Version Selection -->
  <div id="version-select">
    <p style="color: #7f8c8d; margin-bottom: 20px;">Select an experiment version to begin:</p>

    <div class="version-card phonological" onclick="selectVersion('phonological')">
      <h3>Phonological PWI</h3>
      <span class="soa">SOA: +300ms (distractor after picture)</span>
      <p>Distractor words share <strong>onset sounds</strong> with the target picture name.</p>
      <p>Tests phonological encoding during speech production.</p>
      <div class="example">
        <strong>Example:</strong> Picture: üêï (dog) &rarr; Related: "DOLL" | Unrelated: "LAMP"
      </div>
    </div>

    <div class="version-card semantic" onclick="selectVersion('semantic')">
      <h3>Semantic PWI</h3>
      <span class="soa">SOA: -150ms (distractor before picture)</span>
      <p>Distractor words are <strong>category coordinates</strong> (same semantic category).</p>
      <p>Tests lemma selection and lexical competition.</p>
      <div class="example">
        <strong>Example:</strong> Picture: üêï (dog) &rarr; Related: "CAT" | Unrelated: "TABLE"
      </div>
    </div>

    <div class="version-card conceptual" onclick="selectVersion('conceptual')">
      <h3>Conceptual PWI</h3>
      <span class="soa">SOA: -400ms (distractor well before picture)</span>
      <p>Distractor words are <strong>superordinate category names</strong>.</p>
      <p>Tests early conceptual preparation in speech planning.</p>
      <div class="example">
        <strong>Example:</strong> Picture: üêï (dog) &rarr; Related: "ANIMAL" | Unrelated: "VEHICLE"
      </div>
    </div>
  </div>

  <!-- Main Experiment Area (hidden until version selected) -->
  <div id="experiment-area" style="display: none;">
    <div id="current-version"></div>

    <div id="instructions">
      <h3>Instructions</h3>
      <ul>
        <li><strong>Name the picture as quickly as possible</strong> while ignoring the word</li>
        <li><strong>Start typing immediately</strong> when you see the picture</li>
        <li>Press <kbd>Enter</kbd> to submit your response</li>
        <li>Your reaction time is measured from picture onset to your <em>first keystroke</em></li>
      </ul>

      <div class="timing-diagram">
        <p style="margin: 0 0 10px 0; font-size: 12px;">Timing for this version:</p>
        <div class="timeline" id="timing-display"></div>
      </div>
    </div>

    <div id="stimulus-display">
      <div id="fixation">+</div>
      <div id="picture-container" style="display:none;">
        <div id="picture"></div>
        <div id="distractor-word"></div>
      </div>
    </div>

    <div id="feedback"></div>
    <div id="progress"></div>

    <div id="controls">
      <button class="btn" id="start-btn" onclick="startExperiment()">Start Experiment</button>
      <button class="btn btn-secondary" id="back-btn" onclick="backToSelection()">Change Version</button>
    </div>

    <div id="response-input" style="margin: 20px 0;">
      <input type="text" id="response-text" placeholder="Type picture name and press Enter..."
             style="font-size: 18px; padding: 10px; width: 280px; border-radius: 4px; border: 2px solid #3498db;"
             disabled>
      <button class="btn" id="submit-btn" onclick="submitResponse()" disabled>Submit</button>
      <p id="typing-hint" style="font-size: 12px; color: #7f8c8d; margin-top: 5px;">Start typing as soon as you see the picture</p>
    </div>

    <div id="results" style="display:none;">
      <h3>Results</h3>
      <div id="summary-stats"></div>
      <div id="condition-comparison"></div>
      <h4>Trial Data</h4>
      <table id="results-table">
        <thead>
          <tr>
            <th>Trial</th>
            <th>Block</th>
            <th>Item</th>
            <th>Picture</th>
            <th>Distractor</th>
            <th>Condition</th>
            <th>RT (ms)</th>
            <th>Response</th>
            <th>Correct</th>
          </tr>
        </thead>
        <tbody id="results-body"></tbody>
      </table>
      <button class="btn" onclick="downloadResults()">Download CSV</button>
      <button class="btn" onclick="restartExperiment()">Run Again</button>
      <button class="btn btn-secondary" onclick="backToSelection()">Try Different Version</button>
    </div>
  </div>
</div>

<script>
// Version configurations
const versionConfigs = {
  phonological: {
    name: "Phonological PWI",
    soa: 300,  // positive = distractor AFTER picture
    description: "Phonological (onset) relatedness"
  },
  semantic: {
    name: "Semantic PWI",
    soa: -150,  // negative = distractor BEFORE picture
    description: "Semantic (coordinate) relatedness"
  },
  conceptual: {
    name: "Conceptual PWI",
    soa: -400,  // negative = distractor well BEFORE picture
    description: "Conceptual (superordinate) relatedness"
  }
};

// Stimulus sets for each version
const stimuliByVersion = {
  phonological: [
    // Phonological: onset overlap
    { picture: "üêï", name: "dog", related: "doll", unrelated: "lamp" },
    { picture: "üöó", name: "car", related: "cart", unrelated: "boot" },
    { picture: "üå≥", name: "tree", related: "train", unrelated: "sock" },
    { picture: "üìö", name: "book", related: "boot", unrelated: "fish" },
    { picture: "üè†", name: "house", related: "horse", unrelated: "bell" },
    { picture: "‚úàÔ∏è", name: "plane", related: "plate", unrelated: "cork" },
    { picture: "üê±", name: "cat", related: "cap", unrelated: "milk" },
    { picture: "üå∫", name: "flower", related: "flag", unrelated: "tent" },
    { picture: "üëü", name: "shoe", related: "ship", unrelated: "frog" },
    { picture: "‚òÄÔ∏è", name: "sun", related: "sum", unrelated: "kite" },
    { picture: "üçé", name: "apple", related: "anchor", unrelated: "tiger" },
    { picture: "ü™ë", name: "chair", related: "chain", unrelated: "queen" },
  ],
  semantic: [
    // Semantic: category coordinates
    { picture: "üêï", name: "dog", related: "cat", unrelated: "table" },
    { picture: "üöó", name: "car", related: "truck", unrelated: "apple" },
    { picture: "üå≥", name: "tree", related: "flower", unrelated: "chair" },
    { picture: "üìö", name: "book", related: "magazine", unrelated: "shoe" },
    { picture: "üè†", name: "house", related: "apartment", unrelated: "banana" },
    { picture: "‚úàÔ∏è", name: "plane", related: "helicopter", unrelated: "cup" },
    { picture: "üê±", name: "cat", related: "dog", unrelated: "lamp" },
    { picture: "üå∫", name: "flower", related: "tree", unrelated: "phone" },
    { picture: "üëü", name: "shoe", related: "boot", unrelated: "cloud" },
    { picture: "‚òÄÔ∏è", name: "sun", related: "moon", unrelated: "fork" },
    { picture: "üçé", name: "apple", related: "orange", unrelated: "desk" },
    { picture: "ü™ë", name: "chair", related: "table", unrelated: "fish" },
  ],
  conceptual: [
    // Conceptual: superordinate categories
    { picture: "üêï", name: "dog", related: "animal", unrelated: "vehicle" },
    { picture: "üöó", name: "car", related: "vehicle", unrelated: "fruit" },
    { picture: "üå≥", name: "tree", related: "plant", unrelated: "tool" },
    { picture: "üìö", name: "book", related: "reading", unrelated: "food" },
    { picture: "üè†", name: "house", related: "building", unrelated: "animal" },
    { picture: "‚úàÔ∏è", name: "plane", related: "vehicle", unrelated: "plant" },
    { picture: "üê±", name: "cat", related: "animal", unrelated: "furniture" },
    { picture: "üå∫", name: "flower", related: "plant", unrelated: "clothing" },
    { picture: "üëü", name: "shoe", related: "clothing", unrelated: "animal" },
    { picture: "‚òÄÔ∏è", name: "sun", related: "celestial", unrelated: "food" },
    { picture: "üçé", name: "apple", related: "fruit", unrelated: "building" },
    { picture: "ü™ë", name: "chair", related: "furniture", unrelated: "vehicle" },
  ]
};

// Practice/burn-in trials - constant across all participants and versions
// These use different items than the main experiment
const practiceStimuli = {
  phonological: [
    { picture: "üö≤", name: "bike", distractor: "bite", condition: "related" },
    { picture: "üêü", name: "fish", distractor: "lamp", condition: "unrelated" },
    { picture: "üåô", name: "moon", distractor: "XXXX", condition: "neutral" },
  ],
  semantic: [
    { picture: "üö≤", name: "bike", distractor: "car", condition: "related" },
    { picture: "üêü", name: "fish", distractor: "lamp", condition: "unrelated" },
    { picture: "üåô", name: "moon", distractor: "XXXX", condition: "neutral" },
  ],
  conceptual: [
    { picture: "üö≤", name: "bike", distractor: "vehicle", condition: "related" },
    { picture: "üêü", name: "fish", distractor: "furniture", condition: "unrelated" },
    { picture: "üåô", name: "moon", distractor: "XXXX", condition: "neutral" },
  ]
};

// Latin Square Design: 3 lists for counterbalancing
// Items 0-3 = Group A, Items 4-7 = Group B, Items 8-11 = Group C
// Each list assigns different conditions to each group
const latinSquare = {
  1: ["related", "unrelated", "neutral"],    // A=related, B=unrelated, C=neutral
  2: ["unrelated", "neutral", "related"],    // A=unrelated, B=neutral, C=related
  3: ["neutral", "related", "unrelated"]     // A=neutral, B=related, C=unrelated
};

// Experiment state
let currentVersion = null;
let currentList = null;
let trials = [];
let currentTrial = 0;
let currentBlock = 1;
let trialStartTime = 0;
let responseTime = 0;
let results = [];
let experimentPhase = "waiting";
let firstKeypressRecorded = false;

function selectVersion(version) {
  currentVersion = version;
  const config = versionConfigs[version];

  // Update UI
  document.getElementById("version-select").style.display = "none";
  document.getElementById("experiment-area").style.display = "block";

  // Show version badge
  const badge = document.getElementById("current-version");
  badge.textContent = config.name;
  badge.className = version;

  // Update timing diagram
  updateTimingDiagram(config.soa);
}

function updateTimingDiagram(soa) {
  const display = document.getElementById("timing-display");

  if (soa < 0) {
    // Distractor comes first
    display.innerHTML = `
      <span class="marker distractor">WORD</span>
      <span style="color: #7f8c8d;">&rarr; ${Math.abs(soa)}ms &rarr;</span>
      <span class="marker picture">PICTURE</span>
      <span style="color: #7f8c8d; margin-left: 10px;">(measure RT from picture)</span>
    `;
  } else {
    // Picture comes first
    display.innerHTML = `
      <span class="marker picture">PICTURE</span>
      <span style="color: #7f8c8d;">&rarr; ${soa}ms &rarr;</span>
      <span class="marker distractor">WORD</span>
      <span style="color: #7f8c8d; margin-left: 10px;">(measure RT from picture)</span>
    `;
  }
}

function backToSelection() {
  currentVersion = null;
  currentBlock = 1;

  // Exit fullscreen if active
  exitFullscreen();

  document.getElementById("version-select").style.display = "block";
  document.getElementById("experiment-area").style.display = "none";
  document.getElementById("results").style.display = "none";
  document.getElementById("start-btn").style.display = "inline-block";
  document.getElementById("back-btn").style.display = "inline-block";
  document.getElementById("instructions").style.display = "block";
  document.getElementById("response-input").style.display = "block";
  document.getElementById("response-text").disabled = true;
  document.getElementById("response-text").value = "";
  document.getElementById("submit-btn").disabled = true;
  document.getElementById("current-version").style.display = "inline-block";

  // Reset stimulus display
  document.getElementById("stimulus-display").innerHTML = `
    <div id="fixation">+</div>
    <div id="picture-container" style="display:none;">
      <div id="picture"></div>
      <div id="distractor-word"></div>
    </div>
  `;
}

function createTrials() {
  trials = [];
  const stimuli = stimuliByVersion[currentVersion];
  const practice = practiceStimuli[currentVersion];

  // Add practice/burn-in trials first (constant across all participants)
  practice.forEach((prac, index) => {
    trials.push({
      picture: prac.picture,
      targetName: prac.name,
      distractor: prac.distractor,
      condition: prac.condition,
      itemIndex: index,
      group: "practice",
      block: 0,  // Block 0 = practice
      isPractice: true
    });
  });

  // Randomly assign to a list (1, 2, or 3)
  currentList = Math.floor(Math.random() * 3) + 1;

  // Create two blocks with rotated Latin Square assignments
  // Block 1 uses currentList, Block 2 uses rotated list
  const block1List = currentList;
  const block2List = (currentList % 3) + 1;  // Rotate: 1->2, 2->3, 3->1

  const block1Conditions = latinSquare[block1List];
  const block2Conditions = latinSquare[block2List];

  // Create trials for both blocks
  [1, 2].forEach(blockNum => {
    const listConditions = blockNum === 1 ? block1Conditions : block2Conditions;
    const blockTrials = [];

    stimuli.forEach((stim, index) => {
      // Determine which group this item belongs to
      let group;
      if (index < 4) group = 0;       // Group A
      else if (index < 8) group = 1;  // Group B
      else group = 2;                  // Group C

      // Get the condition for this group based on the current block's list
      const condition = listConditions[group];

      // Set the distractor based on condition
      let distractor;
      if (condition === "related") {
        distractor = stim.related;
      } else if (condition === "unrelated") {
        distractor = stim.unrelated;
      } else {
        distractor = "XXXX";
      }

      blockTrials.push({
        picture: stim.picture,
        targetName: stim.name,
        distractor: distractor,
        condition: condition,
        itemIndex: index,
        group: ["A", "B", "C"][group],
        block: blockNum,
        isPractice: false
      });
    });

    // Shuffle trials within each block
    for (let i = blockTrials.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [blockTrials[i], blockTrials[j]] = [blockTrials[j], blockTrials[i]];
    }

    // Add block trials to main trials array
    trials.push(...blockTrials);
  });
}

function enterFullscreen() {
  const container = document.getElementById("experiment-area");
  container.classList.add("fullscreen-mode");

  // Try to request browser fullscreen API
  const docEl = document.documentElement;
  if (docEl.requestFullscreen) {
    docEl.requestFullscreen().catch(() => {});
  } else if (docEl.webkitRequestFullscreen) {
    docEl.webkitRequestFullscreen();
  } else if (docEl.mozRequestFullScreen) {
    docEl.mozRequestFullScreen();
  }
}

function exitFullscreen() {
  const container = document.getElementById("experiment-area");
  container.classList.remove("fullscreen-mode");

  if (document.exitFullscreen) {
    document.exitFullscreen().catch(() => {});
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  }
}

function startExperiment() {
  createTrials();
  currentTrial = 0;
  currentBlock = 1;
  results = [];

  // Enter fullscreen mode
  enterFullscreen();

  document.getElementById("start-btn").style.display = "none";
  document.getElementById("back-btn").style.display = "none";
  document.getElementById("instructions").style.display = "none";
  document.getElementById("results").style.display = "none";
  document.getElementById("response-input").style.display = "block";
  document.getElementById("current-version").style.display = "none";

  runTrial();
}

function runTrial() {
  if (currentTrial >= trials.length) {
    showResults();
    return;
  }

  const trial = trials[currentTrial];
  const config = versionConfigs[currentVersion];
  const soa = config.soa;

  // Track current block from trial data
  currentBlock = trial.block;

  experimentPhase = "fixation";
  firstKeypressRecorded = false;

  // Update progress (don't mention blocks to participant)
  document.getElementById("progress").textContent =
    `Trial ${currentTrial + 1} of ${trials.length}`;

  // Show fixation
  document.getElementById("fixation").style.display = "block";
  document.getElementById("picture-container").style.display = "none";
  document.getElementById("feedback").textContent = "";

  // Disable input during fixation
  const inputEl = document.getElementById("response-text");
  const submitBtn = document.getElementById("submit-btn");
  inputEl.disabled = true;
  inputEl.value = "";
  submitBtn.disabled = true;

  // Variable fixation duration
  const fixationDuration = 500 + Math.random() * 500;

  setTimeout(() => {
    // Prepare stimulus display
    document.getElementById("fixation").style.display = "none";
    document.getElementById("picture-container").style.display = "flex";

    const pictureEl = document.getElementById("picture");
    const distractorEl = document.getElementById("distractor-word");

    pictureEl.textContent = trial.picture;
    distractorEl.textContent = trial.distractor;

    // Reset visibility
    pictureEl.classList.remove("visible");
    distractorEl.classList.remove("visible");

    if (soa < 0) {
      // NEGATIVE SOA: Distractor appears BEFORE picture
      distractorEl.classList.add("visible");

      setTimeout(() => {
        pictureEl.classList.add("visible");
        experimentPhase = "stimulus";
        trialStartTime = performance.now();
        enableInput();
      }, Math.abs(soa));

    } else if (soa > 0) {
      // POSITIVE SOA: Picture appears BEFORE distractor
      pictureEl.classList.add("visible");
      experimentPhase = "stimulus";
      trialStartTime = performance.now();
      enableInput();

      setTimeout(() => {
        distractorEl.classList.add("visible");
      }, soa);

    } else {
      // SOA = 0: Simultaneous
      pictureEl.classList.add("visible");
      distractorEl.classList.add("visible");
      experimentPhase = "stimulus";
      trialStartTime = performance.now();
      enableInput();
    }

  }, fixationDuration);
}

function enableInput() {
  const inputEl = document.getElementById("response-text");
  const submitBtn = document.getElementById("submit-btn");
  inputEl.disabled = false;
  submitBtn.disabled = false;
  inputEl.focus();
}

function recordFirstKeypress() {
  if (experimentPhase !== "stimulus" || firstKeypressRecorded) return;

  responseTime = performance.now() - trialStartTime;
  firstKeypressRecorded = true;
  experimentPhase = "responding";
}

function submitResponse() {
  if (experimentPhase !== "responding" && experimentPhase !== "stimulus") return;

  // If they hit enter without typing, record RT now
  if (!firstKeypressRecorded) {
    responseTime = performance.now() - trialStartTime;
  }

  const response = document.getElementById("response-text").value.trim().toLowerCase();
  const trial = trials[currentTrial];
  const correct = response === trial.targetName.toLowerCase();

  // Record result
  results.push({
    trial: currentTrial + 1,
    practice: trial.isPractice,
    block: trial.block,
    list: currentList,
    version: currentVersion,
    soa: versionConfigs[currentVersion].soa,
    item: trial.itemIndex + 1,
    group: trial.group,
    picture: trial.targetName,
    distractor: trial.distractor,
    condition: trial.condition,
    rt: Math.round(responseTime),
    response: response,
    correct: correct
  });

  // Disable input
  document.getElementById("response-text").disabled = true;
  document.getElementById("submit-btn").disabled = true;

  // Show feedback
  const feedbackEl = document.getElementById("feedback");
  if (correct) {
    feedbackEl.innerHTML = `<span class="correct">Correct! (${Math.round(responseTime)} ms)</span>`;
  } else {
    feedbackEl.innerHTML = `<span class="incorrect">The picture was: ${trial.targetName}</span>`;
  }

  experimentPhase = "feedback";

  // Next trial
  currentTrial++;
  setTimeout(runTrial, 1000);
}

function showResults() {
  experimentPhase = "waiting";
  const config = versionConfigs[currentVersion];

  // Exit fullscreen mode
  exitFullscreen();

  document.getElementById("stimulus-display").innerHTML =
    `<div id="fixation" style="font-size: 24px; color: #27ae60;">Experiment Complete!</div>`;
  document.getElementById("response-input").style.display = "none";
  document.getElementById("progress").textContent = "";
  document.getElementById("feedback").textContent = "";
  document.getElementById("current-version").style.display = "inline-block";

  // Calculate summary statistics (excluding practice trials)
  const experimentalTrials = results.filter(r => !r.practice);
  const correctTrials = experimentalTrials.filter(r => r.correct);
  const accuracy = (correctTrials.length / experimentalTrials.length * 100).toFixed(1);
  const meanRT = correctTrials.length > 0
    ? Math.round(correctTrials.reduce((sum, r) => sum + r.rt, 0) / correctTrials.length)
    : 0;

  // Calculate by condition (excluding practice trials)
  const conditions = ["related", "unrelated", "neutral"];
  const conditionStats = {};

  conditions.forEach(cond => {
    const condTrials = experimentalTrials.filter(r => r.condition === cond && r.correct);
    conditionStats[cond] = {
      n: condTrials.length,
      meanRT: condTrials.length > 0
        ? Math.round(condTrials.reduce((sum, r) => sum + r.rt, 0) / condTrials.length)
        : 0
    };
  });

  // Display summary
  const practiceCount = results.filter(r => r.practice).length;
  document.getElementById("summary-stats").innerHTML = `
    <div class="stat-box">
      <div class="value">List ${currentList}</div>
      <div class="label">Latin Square</div>
    </div>
    <div class="stat-box">
      <div class="value">${experimentalTrials.length}</div>
      <div class="label">Experimental Trials</div>
    </div>
    <div class="stat-box">
      <div class="value">${accuracy}%</div>
      <div class="label">Accuracy</div>
    </div>
    <div class="stat-box">
      <div class="value">${meanRT} ms</div>
      <div class="label">Mean RT</div>
    </div>
  `;

  // Display condition comparison
  const maxRT = Math.max(...Object.values(conditionStats).map(s => s.meanRT)) * 1.2 || 1000;

  const interferenceEffect = conditionStats.related.meanRT - conditionStats.unrelated.meanRT;
  const effectDirection = interferenceEffect > 0 ? "interference" : "facilitation";

  document.getElementById("condition-comparison").innerHTML = `
    <h4>Reaction Time by Condition</h4>
    <p><em>${config.name} (SOA: ${config.soa > 0 ? '+' : ''}${config.soa}ms) - ${config.description}</em></p>
    <p style="font-size: 12px; color: #95a5a6;">2-block Latin Square: 8 trials per condition (24 total trials)</p>
    ${conditions.map(cond => `
      <div class="condition-bar">
        <div class="condition-label">${cond.charAt(0).toUpperCase() + cond.slice(1)} (n=${conditionStats[cond].n})</div>
        <div class="bar-container">
          <div class="bar ${cond}" style="width: ${(conditionStats[cond].meanRT / maxRT * 100)}%">
            ${conditionStats[cond].meanRT} ms
          </div>
        </div>
      </div>
    `).join('')}
    <p style="margin-top: 15px; font-size: 14px; color: #7f8c8d;">
      <strong>${effectDirection.charAt(0).toUpperCase() + effectDirection.slice(1)} effect:</strong>
      ${Math.abs(interferenceEffect)} ms
      (Related ${interferenceEffect > 0 ? '>' : '<'} Unrelated)
    </p>
  `;

  // Display trial table (practice trials shown in grey)
  const tbody = document.getElementById("results-body");
  tbody.innerHTML = results.map(r => `
    <tr style="${r.practice ? 'color: #999; font-style: italic;' : ''}">
      <td>${r.trial}</td>
      <td>${r.practice ? 'P' : r.block}</td>
      <td>${r.item} (${r.group})</td>
      <td>${r.picture}</td>
      <td>${r.distractor}</td>
      <td>${r.condition}</td>
      <td>${r.rt}</td>
      <td>${r.response}</td>
      <td>${r.correct ? '‚úì' : '‚úó'}</td>
    </tr>
  `).join('');

  document.getElementById("results").style.display = "block";
}

function downloadResults() {
  const headers = ["trial", "practice", "block", "list", "version", "soa", "item", "group", "picture", "distractor", "condition", "rt", "response", "correct"];
  const csv = [
    headers.join(","),
    ...results.map(r => headers.map(h => r[h]).join(","))
  ].join("\n");

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `pwi_${currentVersion}_list${currentList}_${new Date().toISOString().slice(0,10)}.csv`;
  a.click();
}

function restartExperiment() {
  currentBlock = 1;

  document.getElementById("stimulus-display").innerHTML = `
    <div id="fixation">+</div>
    <div id="picture-container" style="display:none;">
      <div id="picture"></div>
      <div id="distractor-word"></div>
    </div>
  `;
  document.getElementById("start-btn").style.display = "inline-block";
  document.getElementById("back-btn").style.display = "inline-block";
  document.getElementById("instructions").style.display = "block";
  document.getElementById("results").style.display = "none";
  document.getElementById("response-input").style.display = "block";
  document.getElementById("response-text").disabled = true;
  document.getElementById("response-text").value = "";
  document.getElementById("submit-btn").disabled = true;
}

// Set up input event listeners
document.addEventListener("DOMContentLoaded", () => {
  const inputEl = document.getElementById("response-text");

  // Record RT on first keypress (any printable character)
  inputEl.addEventListener("keydown", (e) => {
    // Record first keypress for RT (ignore Enter, Tab, etc.)
    if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
      recordFirstKeypress();
    }

    // Submit on Enter
    if (e.key === "Enter") {
      e.preventDefault();
      submitResponse();
    }
  });
});
</script>
```

## About Picture-Word Interference

The **Picture-Word Interference (PWI)** paradigm manipulates when distractor words appear relative to pictures (Stimulus Onset Asynchrony, or SOA) to tap into different stages of speech production.

### The Three Versions

| Version | SOA | Distractor Type | What It Tests |
|---------|-----|-----------------|---------------|
| **Phonological** | +300ms | Onset overlap (dog/doll) | Late phonological encoding |
| **Semantic** | -150ms | Category coordinates (dog/cat) | Lemma selection, lexical competition |
| **Conceptual** | -400ms | Superordinates (dog/ANIMAL) | Early conceptual preparation |

### Latin Square Design (2 Blocks)

This experiment uses a **2-block Latin Square** counterbalancing design:

- **3 practice trials**: Warm-up trials using different items (bike, fish, moon), constant across all participants
- **12 experimental items** divided into 3 groups (A, B, C) of 4 items each
- **3 conditions**: Related, Unrelated, Neutral
- **2 blocks**: Each participant completes two blocks back-to-back (seamlessly, no indication shown)
- **24 experimental trials**: Each item appears twice (once per block, in different conditions)
- Each condition has **8 trials** per participant

**Block 1** uses one Latin Square list assignment, **Block 2** uses a rotated assignment:

| List | Block 1: A / B / C | Block 2: A / B / C |
|------|-------------------|-------------------|
| 1    | Rel / Unrel / Neut | Unrel / Neut / Rel |
| 2    | Unrel / Neut / Rel | Neut / Rel / Unrel |
| 3    | Neut / Rel / Unrel | Rel / Unrel / Neut |

Practice trials are excluded from statistical analysis but included in the data download (marked with `practice=true`).

### Why Different Timings?

Different processing stages are active at different times during word production:

- **Early (-400ms)**: Conceptual preparation is happening. Superordinate primes can facilitate or interfere.
- **Mid (-150ms)**: Lemma selection is occurring. This is when semantic competitors cause maximum interference.
- **Late (+300ms)**: Phonological encoding is active. Sound-similar words interfere at this stage.

### Key Findings in the Literature

- **Semantic interference** peaks around SOA -150ms to 0ms (Schriefers et al., 1990)
- **Phonological facilitation** typically occurs at positive SOAs (Starreveld, 2000)
- **Superordinate interference** can occur at very early SOAs (Vitkovitch & Tyrrell, 1999)

### References

- Schriefers, H., Meyer, A. S., & Levelt, W. J. (1990). Exploring the time course of lexical access in language production. *Journal of Memory and Language*, 29(1), 86-102.
- Starreveld, P. A. (2000). On the interpretation of onsets of auditory context effects in word production. *Journal of Memory and Language*, 42(4), 497-525.
- Roelofs, A. (1992). A spreading-activation theory of lemma retrieval in speaking. *Cognition*, 42(1-3), 107-142.
